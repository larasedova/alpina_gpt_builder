name: Build, Push and Deploy

on:
  push:
    branches: [ main, master ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          latest

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Deploy to VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        script: |
          # Создаем директорию проекта
          mkdir -p /opt/alpina_gpt_builder
          cd /opt/alpina_gpt_builder
          
          # Создаем необходимые файлы
          cat > docker-compose.yml << 'EOF'
          version: '3.8'
          
          services:
            web:
              image: ghcr.io/larasedova/alpina_gpt_builder:latest
              container_name: alpina_web
              command: >
                sh -c "python manage.py migrate --noinput &&
                       gunicorn --bind 0.0.0.0:8000 bot_builder.wsgi:application"
              env_file:
                - .env
              volumes:
                - static_volume:/app/staticfiles
                - media_volume:/app/media
              expose:
                - "8000"
              depends_on:
                - db
              restart: unless-stopped
              networks:
                - alpina_network
          
            db:
              image: postgres:15-alpine
              container_name: alpina_db
              environment:
                POSTGRES_DB: alpina_db
                POSTGRES_USER: alpina_user
                POSTGRES_PASSWORD: alpina_password123
              volumes:
                - postgres_data:/var/lib/postgresql/data
              restart: unless-stopped
              networks:
                - alpina_network
          
            nginx:
              image: nginx:1.25-alpine
              container_name: alpina_nginx
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf
                - static_volume:/app/staticfiles:ro
                - media_volume:/app/media:ro
              ports:
                - "80:80"
              depends_on:
                - web
              restart: unless-stopped
              networks:
                - alpina_network
          
          volumes:
            postgres_data:
            static_volume:
            media_volume:
          
          networks:
            alpina_network:
              driver: bridge
          EOF
          
          # Создаем nginx.conf
          cat > nginx.conf << 'EOF'
          events {
              worker_connections 1024;
          }
          
          http {
              include /etc/nginx/mime.types;
              default_type application/octet-stream;
          
              log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                              '$status $body_bytes_sent "$http_referer" '
                              '"$http_user_agent" "$http_x_forwarded_for"';
          
              access_log /var/log/nginx/access.log main;
              error_log /var/log/nginx/error.log;
          
              sendfile on;
              tcp_nopush on;
              tcp_nodelay on;
              keepalive_timeout 65;
              types_hash_max_size 2048;
          
              gzip on;
              gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
          
              upstream django {
                  server web:8000;
              }
          
              server {
                  listen 80;
                  server_name _;
          
                  client_max_body_size 100M;
          
                  location /static/ {
                      alias /app/staticfiles/;
                      expires 1y;
                      add_header Cache-Control "public, immutable";
                      access_log off;
                  }
          
                  location /media/ {
                      alias /app/media/;
                      expires 1y;
                      add_header Cache-Control "public, immutable";
                      access_log off;
                  }
          
                  location / {
                      proxy_pass http://django;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header Host $host;
                      proxy_redirect off;
          
                      proxy_connect_timeout 60s;
                      proxy_send_timeout 60s;
                      proxy_read_timeout 60s;
          
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-Host $server_name;
                  }
          
                  location /health/ {
                      access_log off;
                      return 200 "healthy\n";
                      add_header Content-Type text/plain;
                  }
              }
          }
          EOF
          
          # Создаем .env файл
          cat > .env << EOF
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          DEBUG=False
          ALLOWED_HOSTS=${{ secrets.VPS_HOST }},localhost,127.0.0.1
          OPENAI_API_KEY=demo-mode-no-key-required
          DB_NAME=alpina_db
          DB_USER=alpina_user
          DB_PASSWORD=alpina_password123
          DB_HOST=db
          DB_PORT=5432
          REDIS_URL=redis://redis:6379/0
          EOF
          
          # Логинимся в GitHub Container Registry
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          
          # Останавливаем старые контейнеры
          docker-compose down || true
          
          # Удаляем старый образ (опционально, для экономии места)
          docker image prune -f
          
          # Запускаем контейнеры
          docker-compose pull
          docker-compose up -d
          
          # Ждем запуска и выполняем миграции
          sleep 30
          docker exec alpina_web python manage.py migrate --noinput
          
          # Проверяем статус
          docker-compose ps
          echo "✅ Деплой завершен!"